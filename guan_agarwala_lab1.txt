
EE 108B PONG - LAB1

Charles Guan
Nipun Agarwala

27th January, 2014

INTRODUCTION:
The pong program first draws a ball at a initialized X and Y coordinate position and a paddle at the corresponding Y coordinate but on the left edge. Then, it iterates through the same position 5 times till the counter is greater than the max value. At that moment, the ball is cleared and the program updates the position of the ball by incrementing the X and Y Coordinates of the ball by +/-1 pixel each, depending on which direction the ball is moving towards. That is, on reaching the maximum value of any of the coordinates, the ball starts incrementing the coodrinates by -1 and on reaching the minimum, it increments the coordinates by +1. Immediately, the position of the paddle is updated to be centred using the position of the ball. To update the paddle, we delete one square from one end of the paddle and draw one square on the other end of the paddle. This loop then proceeds as before.

DESIGN:
We decided on having only the main functions called and the counter incremented by the game loop. For that reason, we incorporated the counter loop, draw ball, update paddle, clear ball and set position in the game loop. Since the position of the ball was being used by the paddle, we decided to allocate two registers to hold the X and Y coordinates of the ball respectively. These registers were updated regularly with the most current position of the ball and thus allowed the paddle to update its position respectively. We also stored the direction of increment and the counter is specific registers to keep a permanent track of them.

Since we were drawing squares for both the ball and paddle, we created a special write_square function that updated the required registers with the bytes to be written and then wrote the bytes. Hence, we only needed to set the location and do the edge case checking in the other functions. To make sure that the pixels were shifting slow enough for the eyes to detect, we made every position loop 5 times before updating the position of the ball and paddle. Once the counter was more than the maximum, we called the clear_ball, set_position and update_paddle functions.

The clear_ball function wrote the bytes of he current position of the ball but in black so that the ball blended into the surrounding. Then we checked whether the current position of the ball is on either of the edges. If so, we changed the direction of the ball stored in the respective registers by flipping the sign of the incremental value. After this checking, we update the position of the ball by adding the confirmed incremental values to the current position of the ball and then store them in their respective registers. 

Finally, we update the position of the paddle. Using the current Y coordinate of the ball, the paddle is tried to be centered on the left edge of the screen. But this depends on whether the paddle is at the edges. If the top square of the paddle touches the top edge or the bottom square tocuhes the bottom, the paddle is not moved until the ball is higher than half the square height below or above the edges. After the edge cases are checked, we change the position of the paddle by deleting one square at one edge and adding another on the other edge. If the ball is moving upwards, then the bottom-most square is blackened and one added at the top and vice-versa.

After the paddle is updated, the game loop resumes as before and the infinite pong match continues!
