Nipun Agarwala and Charles Guan
EE108B Lab 1: MIPS Assembly Programming for Pong
January 27, 2014




Results
Drawing the initial stationary paddle and ball proved to be simple. These were implented by short write byte loops. However, to create motion, it is necessary to erase and track the ball and paddle while simultaneously re-drawing them. We stored the locations of both in global variables. For self-playing pong, the y-coordinates of each are matched, so this could be stored in a single variable.
Other issues included coordinate bounding on the paddle when the ball was moving. Since the paddle could not be drawn off the screen that the ball moved upon, it was necessary to ensure that the paddle would stop moving at its edge even though the ball might move for a couple more squares. This required bounds-checking to fix.
The initial design had issues with speed updating the paddle and ball, resulting in visibly flickering paddles and balls. This was caused by the implementation taking large amounts of time to refresh the new images of the ball and paddle. After reviewing the code, it was understood that performance could be enhanced by changing how the paddle was erase and re-written. Out of simplicity, the original implementation erased the entire paddle at each iteration, and then re-drew the entire paddle, which was time-consuming given that 6 paddle blocks and 1 ball block had to be re-drawn each time. To take advantage of the fact that the ball and paddle would only move once in any direction at any iteration, the final implementation draws only one block for the paddle's leading edge (as relative to the paddle motion) and erases only one block for the paddle's tail edge at each iteration. This speeds up the refresh time by about 3.5 times, as the time-consuming number of blocks to erase and redraw is cut down to two.

Conclusions
The pong simulation, built on top of a Python graphics display, can move at a wide range of speeds without flickering. Furthermore, it will robustly play itself forever. The program was well-designed, drawing on the high-level functions that might be used in high-level language implementations. This mindset guided us to appropriate function decomposition that was tedious at first but led to simplified implementaiton later. Because functions in assembly require explicit stack allocation and register saving, we were more wary of unnecessary decomposition.
The program was well-implemented, integrating the ball motion and the paddle motion well with shared variables on the stack. The implementation left room to make extensions flexible. For example, allowing users to control the paddle would simply require reading from the input and jumping to the move_up and move_down modules within the update_paddle function.
Possible changes for next time could include storing global variables on the gp pointer or on the stack.

Software vs Hardware
This software implementation in MIPS assembly was significantly quicker to program than an equivalent hardware implementation in Verilog. The software implementation can also leverage useful packages built into other languages like Python for SPIM simulation. These simulations do not require lengthy syntheses to verify. However, appropriate hardware implementation would benefit from performance improvements and parallel writing. For example, the paddle drawing was slowed down because the bytes had to be written in sequence, with each pixel waiting for the one before it. However, in hardware, the paddle could be redrawn almost simultaneously and would reduce the issues with flicker. Similarly, tracking multiple paddles to update or keeping track of all the bricks in Breakout would be simpler in hardware. Again, however, the initial design would take more time, requiring FSMs and timing taken care of by loops in the software design. The user-controlled paddle would also be more difficult in the hardware implementation simply because debouncing any input WADS signal would be significantly time-consuming to test first.
